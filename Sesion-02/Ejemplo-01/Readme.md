`Desarrollo Web` > `BackEnd B√°sico Java`

## üß† Ejemplo 01: Patrones Creacionales

### üéØ OBJETIVO

- Aprender los casos de uso de los Patrones Creacionales

### üìÉ REQUISITOS

1. Tener **Gradle** instalado en el equipo
2. Tener un editor de c√≥digo instalado en el equipo
3. Tener acceso a la terminal del equipo

### üé© DESARROLLO

Los patrones de dise√±o **creacionales** son aquellos que nos proponen soluciones para problemas relacionados con la instanciaci√≥n de objetos. Automatizar el proceso de construcci√≥n de un objeto complejo, limitar la instanciaci√≥n de una clase a un √∫nico objeto al que se pueda acceder de manera global o usar un objeto como prototipo para crear otros objetos similares son algunos de los usos de los patrones de dise√±o creacionales.

A continuaci√≥n analizaremos uno de los patrones creacionales m√°s importantes que es **Singleton**.

El patr√≥n **Singleton** resuelve dos problemas al mismo tiempo, vulnerando el Principio de responsabilidad √∫nica:

Garantizar que una clase tenga una √∫nica instancia. ¬øPor qu√© querr√≠a alguien controlar cu√°ntas instancias tiene una clase? El motivo m√°s habitual es controlar el acceso a alg√∫n recurso compartido, por ejemplo, una base de datos o un archivo.

Funciona as√≠: imagina que has creado un objeto y al cabo de un tiempo decides crear otro nuevo. En lugar de recibir un objeto nuevo, obtendr√°s el que ya hab√≠as creado.

Ten en cuenta que este comportamiento es imposible de implementar con un constructor normal, ya que una llamada al constructor siempre debe devolver un nuevo objeto por dise√±o.

Todas las implementaciones del patr√≥n **Singleton** tienen estos dos pasos en com√∫n:

- Hacer privado el constructor por defecto para evitar que otros objetos utilicen el operador new con la clase **Singleton**.
- Crear un m√©todo de creaci√≥n est√°tico que act√∫e como constructor. Tras bambalinas, este m√©todo invoca al constructor privado para crear un objeto y lo guarda en un campo est√°tico. Las siguientes llamadas a este m√©todo devuelven el objeto almacenado en cach√©.
- Si tu c√≥digo tiene acceso a la clase **Singleton**, podr√° invocar su m√©todo est√°tico. De esta manera, cada vez que se invoque este m√©todo, siempre se devolver√° el mismo objeto.

A continuaci√≥n tenemos su implementaci√≥n en Java:

```java
public class Singleton {

  private static Singleton instance;
  public String value;

  private Singleton(String value) {
    this.value = value;
  }

  public static Singleton getInstance(String value) {
    if (instance == null) {
      instance = new Singleton(value);
    }

    return instance;
  }
}
```

Con dicha implementaci√≥n garantizamos que al momento de llamar el m√©todo est√°tico `getInstance` obtendremos siempre la misma instancia sin importar el valor que tenga como par√°metro el m√©todo.

Ahora implementamos una clase que utilice nuestra implementaci√≥n de Singleton para verificar su funcionamiento:

```java
public class PruebaSingleton {

  public static void main(String[] args) {
    Singleton singleton = Singleton.getInstance("FOO");
    Singleton anotherSingleton = Singleton.getInstance("BAR");

    System.out.println(singleton.value);
    System.out.println(anotherSingleton.value);
  }
}
```

Por √∫ltimo creamos el archivo `build.gradle` para compilar y ejecutar el c√≥digo:

```groovy
plugins {
  id 'application'
}

application {
  mainClass = "PruebaSingleton"
}
```

Finalmente ejecutamos el comando `gradle run` y verificaremos que la salida del programa es la repetici√≥n de la palabra "FOO".